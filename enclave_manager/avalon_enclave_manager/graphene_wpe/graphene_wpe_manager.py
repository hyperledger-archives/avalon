#!/usr/bin/env python3

# Copyright 2020 Intel Corporation
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import argparse
import json
import logging
import os
import sys
import random

from avalon_enclave_manager.base_enclave_manager import EnclaveManager
from avalon_enclave_manager.work_order_processor_manager \
    import WOProcessorManager
from avalon_enclave_manager.wpe_common.wpe_requester import WPERequester
from avalon_enclave_manager.wpe_common.wo_processor_manager_helper \
    import WOProcessorEnclaveManagerHelper
from avalon_enclave_manager.graphene_wpe.graphene_wpe_enclave_info \
    import GrapheneWPESignupInfo
from utility.zmq_comm import ZmqCommunication
from utility.jrpc_utility import get_request_json


logger = logging.getLogger(__name__)


class GrapheneWPEManager(
        WOProcessorEnclaveManagerHelper, WOProcessorManager):
    """
    Manager class to handle work order processing in a worker
    pool setup with Graphene
    """

    def __init__(self, config):
        # zmq socket has to be created before calling super class constructor
        # super class constructor calls _create_signup_data() which uses
        # socket for communicating with Graphene worker.
        graphene_zmq_url = config.get("EnclaveManager")["graphene_zmq_url"]
        self.zmq_socket = ZmqCommunication(graphene_zmq_url)
        self.zmq_socket.connect()
        WOProcessorManager.__init__(self, config)
        WOProcessorEnclaveManagerHelper.__init__(self)
        self._identity = self._worker_id
        self._config = config

# -------------------------------------------------------------------------

    def _create_signup_data(self):
        """
        Create Graphene WPE signup data.

        Returns :
            signup_data - Relevant signup data to be used for requests to the
                          enclave
        """
        # Instantiate WPERequester which will help communicate with the KME
        self._wpe_requester = WPERequester(self._config)

        # Generate a nonce
        verification_key_nonce = self._generate_nonce()
        logger.info("Nonce generated by requester WPE : %s",
                    verification_key_nonce)
        response = self._wpe_requester.get_unique_verification_key(
            verification_key_nonce)
        if response is None:
            logger.error("Failed to get Unique ID from KME")
            return None
        # Received response contains result,verification_key and
        # verification_key_signature delimited by ' '
        self._unique_verification_key = response.split(' ')[1]
        self._unique_verification_key_signature = response.split(' ')[2]

        # Verify unique verification key signature using unique id
        result = self._verify_unique_id_signature(
            self._unique_verification_key,
            self._unique_verification_key_signature)
        if result != 0:
            logger.error("Failed to verify unique id signature")
            return None
        worker_signup_json = self._signup_worker(
            self._unique_verification_key)
        # signup enclave
        signup_data = GrapheneWPESignupInfo(self._config, worker_signup_json)
        self.mr_enclave = signup_data.get_enclave_measurement()
        # return signup data
        logger.info("WPE signup data {}".format(signup_data.proof_data))
        return signup_data

# -------------------------------------------------------------------------

    def _generate_nonce(self):
        """
        Generate a nonce that is supposed to be used by the KME to generate
        the unique verification key

        Returns:
            @returns nonce - A 32 character nonce generated by worker
        """
        nonce = None
        json_request = get_request_json("GenerateNonce",
                                        random.randint(0, 100000),
                                        {"nonce_size": 32})

        try:
            # Get a nonce generated at Graphene worker
            response = self.zmq_socket.send_request_zmq(
                json.dumps(json_request))
            nonce = json.loads(response)["nonce"]
        except Exception as ex:
            logger.error("Exception while sending data over ZMQ:" + str(ex))
        return nonce

# -------------------------------------------------------------------------

    def _verify_unique_id_signature(self, verif_key, verif_key_sig):
        """
        Method to get nonce from the worker which shall be used to get a
        unique verification key from the KME

        Parameters :
            @param verif_key - Unique verification key
            @param verif_key_sig - Signature of the key as generated by the KME
        Returns :
            @returns result - 0 or 1 boolean result of verification
        """
        params = {"uniqueVerificationKey": verif_key,
                  "uniqueVerificationKeySignature": verif_key_sig}
        json_request = get_request_json("VerifyUniqueIdSignature",
                                        random.randint(0, 100000), params)
        res = -1
        try:
            response = self.zmq_socket.send_request_zmq(
                json.dumps(json_request))
            res = json.loads(response)["verification_result"]
        except Exception as ex:
            logger.error("Exception while sending data over ZMQ:" + str(ex))
        return res

# -------------------------------------------------------------------------

    def _signup_worker(self, unique_verif_key):
        """
        Signup worker ky sending signup request to worker.

        Parameters:
            @param unique_verif_key - Unique verification key obtained from
            the KME
        Returns:
            @returns worker_signup_json - Signup details of worker after signup
        """
        params = {"uniqueVerificationKey": unique_verif_key}
        json_request = get_request_json("ProcessWorkerSignup",
                                        random.randint(0, 100000), params)
        try:
            # Send signup request to Graphene worker
            worker_signup = self.zmq_socket.send_request_zmq(
                json.dumps(json_request))
        except Exception as ex:
            logger.error("Exception while sending data over ZMQ:" + str(ex))
            return None

        if worker_signup is None:
            logger.error("Unable to get Graphene worker signup data")
            return None
        logger.debug("Graphene signup result {}".format(worker_signup))
        try:
            worker_signup_json = json.loads(worker_signup)
        except Exception as ex:
            logger.error("Exception during signup json creation:" + str(ex))
            return None
        return worker_signup_json

# -------------------------------------------------------------------------

    def _send_wo_to_process(self, input_json_str, pre_proc_output):
        """
        Overridden method from WorkOrderProcessorEnclaveManager.
        Send work order request for processing..

        Parameters :
            input_json_str - A JSON formatted str of the request to execute
            pre_proc_output - Preprocessing outcome of the work-order request
        Returns :
            response - Response as received after work-order execution
        """
        json_request = get_request_json(
            "ProcessWorkOrder", random.randint(0, 100000),
            [input_json_str, pre_proc_output])
        try:
            # Send work order request to WPE Graphene worker
            wo_result = self.zmq_socket.send_request_zmq(
                json.dumps(json_request))
        except Exception as ex:
            logger.error("Exception while sending data over ZMQ:" + str(ex))
            return None

        if wo_result is None:
            logger.error("WPE Graphene work order execution error")
            return None
        try:
            wo_result_json = json.loads(wo_result)
        except Exception as ex:
            logger.error("Error loading json execution result:" + str(ex))
            return None
        return wo_result_json

# -------------------------------------------------------------------------


def main(args=None):
    import config.config as pconfig
    import utility.logger as plogger

    # parse out the configuration file first
    tcf_home = os.environ.get("TCF_HOME", "../../../")

    conf_files = ["graphene_wpe_config.toml"]
    conf_paths = [".", tcf_home + "/"+"config"]

    parser = argparse.ArgumentParser()
    parser.add_argument("--config", help="configuration file", nargs="+")
    parser.add_argument("--config-dir", help="configuration folder", nargs="+")
    parser.add_argument("--kme_listener_url",
                        help="KME listener url for requests to KME",
                        type=str)
    parser.add_argument(
        "--worker_id", help="Id of worker in plain text", type=str)

    (options, remainder) = parser.parse_known_args(args)

    if options.config:
        conf_files = options.config

    if options.config_dir:
        conf_paths = options.config_dir

    try:
        config = pconfig.parse_configuration_files(conf_files, conf_paths)
        json.dumps(config, indent=4)
    except pconfig.ConfigurationException as e:
        logger.error(str(e))
        sys.exit(-1)

    if options.kme_listener_url:
        config["KMEListener"]["kme_listener_url"] = options.kme_listener_url
    if options.worker_id:
        config["WorkerConfig"]["worker_id"] = options.worker_id

    plogger.setup_loggers(config.get("Logging", {}))
    sys.stdout = plogger.stream_to_logger(
        logging.getLogger("STDOUT"), logging.DEBUG)
    sys.stderr = plogger.stream_to_logger(
        logging.getLogger("STDERR"), logging.WARN)

    try:
        EnclaveManager.parse_command_line(config, remainder)
        logger.info("Initialize GrapheneWPEManager")
        enclave_manager = GrapheneWPEManager(config)
        enclave_manager.start_enclave_manager()
    except Exception as e:
        logger.error("Exception occurred while running Graphene WPE, " +
                     "exiting from the enclave manager")
        exit(1)


main()
